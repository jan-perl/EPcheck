//todo
//cleanup

// lowercase uit delen match expressies halen


container EPcheck
{

container Classifications: Using = "Units", KeepData = "True", IsHidden = "True"
{
// =========  Classificaties voor Percentages
	unit<uint8> Percentage13K: nrofrows = 13
	{
		attribute<percent> ClassBreaks: DialogType = "Classification",
			[0,10,20,30,40,50,60,70,80,90,100,120,150];

		attribute<uint32> BrushColor : DialogType = "BrushColor",
			[
				 rgb(255,255,255),rgb(255,229,204),rgb(255,204,153)
				,rgb(255,178,102),rgb(255,153, 51),rgb(255,128,  0)
				,rgb(223, 96, 32),rgb(191, 64, 64),rgb(180,  0,  0)
				,rgb(120,  0,  0),rgb( 60,  0,  0),rgb(120,  0,128),rgb(255,  0,200)
			];

		attribute<string> label : DialogType = "LabelText",
			[' 0 -  10','10 -  20','20 -  30','30 -  40','40 -  50','50 -  60','60 -  70','70 -  80','80 -  90','90 - 100','100- 120','120- 150','150- 200'];
	}

	unit<uint8> Ratio13F: nrofrows = 12
	{
		attribute<ratio> ClassBreaks: DialogType = "Classification",
			[0,.2,.3,.4,.5,.55,.6,.65,.7,.75,.8,.9];

		attribute<uint32> BrushColor : DialogType = "BrushColor",
			[
				rgb(255,229,204),rgb(255,204,153)
				,rgb(255,178,102),rgb(255,153, 51),rgb(255,128,  0)
				,rgb(223, 96, 32),rgb(191, 64, 64),rgb(180,  0,  0)
				,rgb(120,  0,  0),rgb( 60,  0,  0),rgb(120,  0,128),rgb(255,  0,200)
			];

		attribute<string> label : DialogType = "LabelText",
			['0 -  20','20 -  30','30 -  40','40 -  50','50 -  55','55 -  60','60 -  65','65 -  70','70 -  75',' 75-  80',' 80-  90',' 90- '];
	}

	unit<uint8> ratio9K: nrofrows = 9
	{
		attribute<ratio> ClassBreaks: DialogType = "Classification",
			[0,0.0001,0.15,0.30,0.45,0.60,0.75,0.90,1.05];

		attribute<uint32> BrushColor: DialogType = "BrushColor",
			[
				 rgb(218,218,218), rgb(255,255,204),rgb(255,255,128)
				,rgb(255,230,102), rgb(255,179, 51),rgb(255,128,  0)
				,rgb(255, 51,  0), rgb(230,  0,  0),rgb(153,  0,  0)
			];

		attribute<uint32> SymbolColor:= BrushColor, DialogType = "SymbolColor";

		attribute<string> label : DialogType = "LabelText",
			[' 0 ', '0    - 0.15', '0.15 - 0.30', '0.30 - 0.45', '0.45 - 0.60', '0.60 - 0.75', '0.75 - 0.90', '0.90 - 1.05', '> 1.05'];
	}

	unit<uint8> ratio9F: nrofrows = 8
	{
		attribute<ratio> ClassBreaks: DialogType = "Classification",
			[0,0.40,0.55,0.65,0.70,0.75, 0.8,0.9];

		attribute<uint32> BrushColor: DialogType = "BrushColor",
			[
				 rgb(255,255,204),rgb(255,255,128)
				,rgb(255,230,102), rgb(255,179, 51),rgb(255,128,  0)
				,rgb(255, 51,  0), rgb(230,  0,  0),rgb(153,  0,  0)
			];

		attribute<uint32> SymbolColor:= BrushColor, DialogType = "SymbolColor";

		attribute<string> label : DialogType = "LabelText",
			[ '0    - 0.40', '0.40 - 0.55', '0.55 - 0.65', '0.65 - 0.70', '0.70 - 0.75',  '0.75 - 0.80','0.80 - 0.90', '> 0.90'];
	}

		unit<uint8> example_for_size: nrofrows = 3 // Domain unit with three rows
		{
			attribute<nr_inh> ClassBreaks: [      0, 1000000  ,2000000];                                        // Set classbreaks at given intervals of inhabitants
			attribute<string> label:       ['small', 'medium' ,'large'];                                        // Semantic labels
			attribute<uint32> BrushColor:  [rgb(0,255,0),rgb(0,0,255),rgb(255,0,0)], DialogType = "BrushColor"; // Use colors: Green, Blue, Red
		}
}

	container Units // Definition of value units
	{

//    #include <Classifications.dms> 
 
		unit<float32> nr_inh := baseunit('inhabitants', float32);
		
		unit<float64> m      := baseunit('meter', float64);
		unit<float64> km     := 1000 * m;
		unit<float64> m2     := m * m;

	// no metric
	unit<float64> ratio         := range(1.0 * m2 / m2, 0.0, 1.0)	, cdf = "Classifications/ratio13F/ClassBreaks";
	unit<float64> percent       := 100.0 * ratio;
// , cdf = "Classifications/Percentage13K/ClassBreaks";

		unit<float32> s      := baseunit('second', float32);
		unit<float32> hr     := 3600 * s;

		unit<float32> km_hr  := km / hr;
	}

//    #include<Geography.dms> 
 
	container Geography // Define the extend of the scene and the projection 
	{
		unit<fpoint> rdc_base : format = "EPSG:28992", DialogData = "ngr_layer";               // Rijksdriehoekstelsel, a 2D cartesian coordinate system for the netherlands
		unit<fpoint> rdc_meter      := range(rdc_base, point(0f, 300000f), point(280000f, 625000f)); // Define a 2D range consisting of 2D cartesian coordinates, later used for the "province" domain unit geometry attribute
		unit<fpoint> rdc      := Geography/rdc_meter;

		#include<ngr_layer.dms>                                                                // Tiles for background layer
	}

	container SourceData: Using = "Units"
	{


	container bag_snapshot_result: 
  StorageName     = "%ProjDir%/data/bag_snapshot_20221001/snapshot_20221001.gpkg" // Path to shapefile (2D spatial dataset + N attributes)
, StorageType     = "gdal.vect"
, StorageReadOnly = "True"
, SyncMode        = "allTables"
, DialogData      = "geography/point_rd";

    unit<uint32> epdata_c
:  StorageName     = "%ProjDir%/data/v20230101_v2_csv.csv"
,  StorageType     = "gdal.vect"
,  SyncMode        = "allTables"
,  StorageReadOnly = "True" {
    	   attribute<string> ep_pcncmb   := ( Pand_postcode + 
			     Pand_huisnummer + uppercase(Pand_huisletter) +"-" + lowercase(Pand_huisnummertoevoeging)  );
			 attribute<string> ep_klaslet   := substr( Pand_energieklasse,0,1 );
        }

    unit<uint32> epdata_d
:  StorageName     = "%ProjDir%/data/epdata_d.dbf"  
,  SyncMode        = "allTables"
,  StorageReadOnly = "True" {
         attribute<string> Pand_energieklasse  := PAND_ENERG + "";
//		 attribute<string> Pand_gebouwklasse   := PAND_GEBOU ;
//		 attribute<string> Pand_gebruiksoppervlakte_thermische_zone    := PAND_GEBRU ;
        }

	  	  unit<uint32> epdata   :
                    StorageName = "%ProjDir%/data/epdata_f.fss" 
					 ,  SyncMode        = "allTables"
,  StorageReadOnly = "True"       {
         attribute<string> ep_pcncmb;        
		 attribute<string> ep_pcncmbu := uppercase(ep_pcncmb);
		 attribute<string> ep_klaslet   ;
         attribute<string> Pand_energieklasse  ;
		 attribute<string> Pand_gebouwklasse ;
		 attribute<string> Pand_gebruiksoppervlakte_thermische_zone  ;
      } 

    unit<uint32> gemfrompc4c
:  StorageName     = "%ProjDir%/data/gemfrompc4.csv"
,  StorageType     = "gdal.vect"
,  SyncMode        = "allTables"
,  StorageReadOnly = "True" ;

    unit<uint32> gemfrompc4
:  StorageName = "%ProjDir%/data/gemfrompc4f.fss"
,  StorageReadOnly = "True" {

   attribute<string> Postcode4  ;
   attribute<string> Gemeentenaam;

}


    unit<uint32> gemfrompc4d
:  StorageName = "%ProjDir%/data/gemfrompc4d.dbf"
,  StorageReadOnly = "True" ;


//    unit<uint32> gemfrompc4 := gemfrompc4d;

	}


	container ToDbf: Using = "Units"
	{
	     unit<uint32> i_pc4_dbf  := SourceData/gemfrompc4c ,
                    StorageName = "%ProjDir%/data/gemfrompc4d.dbf"        {
         attribute<string> Postcode4  := SourceData/gemfrompc4c/Postcode4;
         attribute<string> Gemeentenaam:= SourceData/gemfrompc4c/Gemeentenaam;
      } 
	  
	  unit<uint32> i_epdat_dbf  := SourceData/epdata ,
                    StorageName = "%ProjDir%/data/epdata_d.dbf"        {
         attribute<string> pcncmb  := SourceData/epdata/ep_pcncmb;
		 attribute<string> klaslet   := SourceData/epdata/ep_klaslet ;
         attribute<string> energiekl   := SourceData/epdata/Pand_energieklasse ;
		 attribute<string> gebouwkl   := SourceData/epdata/Pand_gebouwklasse ;
		 attribute<string> gebropp   := SourceData/epdata/Pand_gebruiksoppervlakte_thermische_zone ;
      } 
	  
	  	  unit<uint32> i_epdat_fss  := SourceData/epdata_c ,
                    StorageName = "%ProjDir%/data/epdata_f.fss"        {
         attribute<string> ep_pcncmb  := SourceData/epdata_c/ep_pcncmb;
		 attribute<string> ep_klaslet  := SourceData/epdata_c/ep_klaslet ;
         attribute<string> Pand_energieklasse  := SourceData/epdata_c/Pand_energieklasse ;
		 attribute<string> Pand_gebouwklasse := SourceData/epdata_c/Pand_gebouwklasse ;
		 attribute<string> Pand_gebruiksoppervlakte_thermische_zone   := SourceData/epdata_c/Pand_gebruiksoppervlakte_thermische_zone ;
      } 
	  
	  unit<uint32> i_gemfrompc4_fss := SourceData/gemfrompc4c
,   StorageName = "%ProjDir%/data/gemfrompc4f.fss"
{

   attribute<string> Postcode4  := SourceData/gemfrompc4c/Postcode4;
   attribute<string> Gemeentenaam:= SourceData/gemfrompc4c/Gemeentenaam;

}
	}
	
	container Results: Using = "Units"
	{

		container koppel1
		{
		  
		    unit<uint32> selectforlab := subset( 
			    ( SourceData/bag_snapshot_result/vbo/woon == False ) &&   
			    ( SourceData/bag_snapshot_result/vbo/industrie == False ) &&
				( SourceData/bag_snapshot_result/vbo/oppervlakte >=  Int32( 100 ) ) )
                 {
                    attribute<string> nummeraanduiding_id  := SourceData/bag_snapshot_result/vbo/nummeraanduiding_id[Nr_OrgEntity];
                    attribute<Int32> oppervlakte   := SourceData/bag_snapshot_result/vbo/oppervlakte[Nr_OrgEntity];
                 }

              
		    unit<uint32> eputil := subset( 
			           ( SourceData/epdata/Pand_gebouwklasse == "U"  ) )
                 {
				    attribute<string> ep_pcncmb   := SourceData/epdata/ep_pcncmbu [Nr_OrgEntity];
                    attribute<string> ep_klaslet  := SourceData/epdata/ep_klaslet [Nr_OrgEntity];
					attribute<string> Pand_gebouwklasse  := SourceData/epdata/Pand_gebouwklasse [Nr_OrgEntity];
					attribute<string> Pand_energieklasse   := SourceData/epdata/Pand_energieklasse  [Nr_OrgEntity];
                    attribute<Float32> oppervlakte   := Float32(SourceData/epdata/Pand_gebruiksoppervlakte_thermische_zone [Nr_OrgEntity]);
                 }
				 
		    attribute<UInt32> adres_idx_vbo (selectforlab ) := rlookup(selectforlab/nummeraanduiding_id,
  			      SourceData/bag_snapshot_result/adres/nummeraanduiding_id );
				  
			attribute<string> adr_pcncmb  (SourceData/bag_snapshot_result/adres) := uppercase( SourceData/bag_snapshot_result/adres/postcode + 
			 String(SourceData/bag_snapshot_result/adres/huisnummer) + uppercase(SourceData/bag_snapshot_result/adres/Huisletter) + "-" + lowercase(SourceData/bag_snapshot_result/adres/toevoeging)) ;
			
		    attribute<UInt32> adres_idx_ep (eputil) :=  rlookup(eputil/ep_pcncmb,  adr_pcncmb );		  
		  
		    unit<uint32> epnoaddr := subset( 
			      IsNull( adres_idx_ep ) &&  
				   ( eputil/ep_pcncmb!= "-" )  &&
                  (  eputil/Pand_gebouwklasse == "U" ) )
                 {
                    attribute<string> ep_pcncmb_res:= eputil/ep_pcncmb[Nr_OrgEntity];
                    attribute<string> Pand_energieklasse   := eputil/Pand_energieklasse[Nr_OrgEntity];
					attribute<string> ep_pc4  := substr(ep_pcncmb_res,0,4);
			        attribute<string> ep_gemeente := rjoin(ep_pc4,
			              SourceData/gemfrompc4/Postcode4,SourceData/gemfrompc4/Gemeentenaam  );
                 }		 


            // eventueel restgroep matchen zonder toevoeging
			
			// aparte export WEL epo en adres , GEEN VBO record met U
			// let op: dat kunnen ook adresen zijn met kleinere oppervlakten

            attribute<UInt32> ep_idx_vbo (selectforlab ) := rlookup(adres_idx_vbo,  adres_idx_ep );
			attribute<string> select_klaslet (selectforlab ) := eputil/ep_klaslet [ep_idx_vbo];
			attribute<string> select_ep_pcncmb (selectforlab ) := adr_pcncmb [adres_idx_vbo];
			attribute<string> select_Straatnaam (selectforlab ) := SourceData/bag_snapshot_result/adres/Straatnaam [adres_idx_vbo];
			attribute<string> select_pc4 (selectforlab ) := substr(select_ep_pcncmb,0,4);
			attribute<string> select_gemeente (selectforlab ) := rjoin(select_pc4,
			    SourceData/gemfrompc4/Postcode4,SourceData/gemfrompc4/Gemeentenaam  );
			
			// code maken dat oude dbf eerst gewist wordt

	  unit<uint32> i_land_dbf  := selectforlab,
                    StorageName = "%ProjDir%/output/outp2land.dbf"        {
         attribute<string> pcncmb  :=select_ep_pcncmb;
		 attribute<string> klaslet   := makedefined(select_klaslet," ") ;
         attribute<string> gemeente   := select_gemeente ;
		 attribute<string> straat   := select_Straatnaam ;
		 attribute<float32> ep_opp   := eputil/oppervlakte[ep_idx_vbo] ;
		 attribute<int32> vbo_opp   := selectforlab/oppervlakte ;
      } 


        }
		

		
	}
}