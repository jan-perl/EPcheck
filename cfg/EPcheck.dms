//todo
//cleanup

// lowercase uit delen match expressies halen

container EPcheck
{

container Classifications: Using = "Units", KeepData = "True", IsHidden = "True"
{
// =========  Classificaties voor Percentages
	unit<uint8> Percentage13K: nrofrows = 13
	{
		attribute<percent> ClassBreaks: DialogType = "Classification",
			[0,10,20,30,40,50,60,70,80,90,100,120,150];

		attribute<uint32> BrushColor : DialogType = "BrushColor",
			[
				 rgb(255,255,255),rgb(255,229,204),rgb(255,204,153)
				,rgb(255,178,102),rgb(255,153, 51),rgb(255,128,  0)
				,rgb(223, 96, 32),rgb(191, 64, 64),rgb(180,  0,  0)
				,rgb(120,  0,  0),rgb( 60,  0,  0),rgb(120,  0,128),rgb(255,  0,200)
			];

		attribute<string> label : DialogType = "LabelText",
			[' 0 -  10','10 -  20','20 -  30','30 -  40','40 -  50','50 -  60','60 -  70','70 -  80','80 -  90','90 - 100','100- 120','120- 150','150- 200'];
	}

	unit<uint8> Ratio13F: nrofrows = 12
	{
		attribute<ratio> ClassBreaks: DialogType = "Classification",
			[0,.2,.3,.4,.5,.55,.6,.65,.7,.75,.8,.9];

		attribute<uint32> BrushColor : DialogType = "BrushColor",
			[
				rgb(255,229,204),rgb(255,204,153)
				,rgb(255,178,102),rgb(255,153, 51),rgb(255,128,  0)
				,rgb(223, 96, 32),rgb(191, 64, 64),rgb(180,  0,  0)
				,rgb(120,  0,  0),rgb( 60,  0,  0),rgb(120,  0,128),rgb(255,  0,200)
			];

		attribute<string> label : DialogType = "LabelText",
			['0 -  20','20 -  30','30 -  40','40 -  50','50 -  55','55 -  60','60 -  65','65 -  70','70 -  75',' 75-  80',' 80-  90',' 90- '];
	}

	unit<uint8> ratio9K: nrofrows = 9
	{
		attribute<ratio> ClassBreaks: DialogType = "Classification",
			[0,0.0001,0.15,0.30,0.45,0.60,0.75,0.90,1.05];

		attribute<uint32> BrushColor: DialogType = "BrushColor",
			[
				 rgb(218,218,218), rgb(255,255,204),rgb(255,255,128)
				,rgb(255,230,102), rgb(255,179, 51),rgb(255,128,  0)
				,rgb(255, 51,  0), rgb(230,  0,  0),rgb(153,  0,  0)
			];

		attribute<uint32> SymbolColor:= BrushColor, DialogType = "SymbolColor";

		attribute<string> label : DialogType = "LabelText",
			[' 0 ', '0    - 0.15', '0.15 - 0.30', '0.30 - 0.45', '0.45 - 0.60', '0.60 - 0.75', '0.75 - 0.90', '0.90 - 1.05', '> 1.05'];
	}

	unit<uint8> ratio9F: nrofrows = 8
	{
		attribute<ratio> ClassBreaks: DialogType = "Classification",
			[0,0.40,0.55,0.65,0.70,0.75, 0.8,0.9];

		attribute<uint32> BrushColor: DialogType = "BrushColor",
			[
				 rgb(255,255,204),rgb(255,255,128)
				,rgb(255,230,102), rgb(255,179, 51),rgb(255,128,  0)
				,rgb(255, 51,  0), rgb(230,  0,  0),rgb(153,  0,  0)
			];

		attribute<uint32> SymbolColor:= BrushColor, DialogType = "SymbolColor";

		attribute<string> label : DialogType = "LabelText",
			[ '0    - 0.40', '0.40 - 0.55', '0.55 - 0.65', '0.65 - 0.70', '0.70 - 0.75',  '0.75 - 0.80','0.80 - 0.90', '> 0.90'];
	}

		unit<uint8> example_for_size: nrofrows = 3 // Domain unit with three rows
		{
			attribute<nr_inh> ClassBreaks: [      0, 1000000  ,2000000];                                        // Set classbreaks at given intervals of inhabitants
			attribute<string> label:       ['small', 'medium' ,'large'];                                        // Semantic labels
			attribute<uint32> BrushColor:  [rgb(0,255,0),rgb(0,0,255),rgb(255,0,0)], DialogType = "BrushColor"; // Use colors: Green, Blue, Red
		}
		
		unit<uint32> Uitkomstcats : nrofrows = 3
	{
		attribute<string> name  : [ 'geen', 'NOK', 'OK' ];
		attribute<string> label := name, DialogType = "LabelText";
		attribute<uint32> BrushColor: DialogType = "BrushColor",
			[				 rgb(255,0,0),rgb(0,0,255),rgb(0,255,0) 		    ];
        attribute<uint32>  SymbolColor :=  DialogType = "SymbolColor",
		    [				 rgb(255,0,0),rgb(0,0,255),rgb(0,255,0) 		    ];
        attribute<float32> SymbolSize  := DialogType = "SymbolSize", [ 4.0,4.0,4.0]     ;
        attribute<uint32>  Color :=  DialogType = "BrushColor",
		    [				 rgb(255,255,0),rgb(0,0,255),rgb(0,255,0),rgb(255,0,0) 		   ];


        container V := for_each_nedv(name, 'value('+string(id(.))+', ..)', void, .);
	}
	
	    unit<uint32> UitkomstUitval : nrofrows = 4
	{
		attribute<string> name  : [ 'geenNietWoon', 'Industrie', 'Klein', 'Uitzoeken' ];
		attribute<string> label := name, DialogType = "LabelText";
		attribute<uint32> BrushColor: DialogType = "BrushColor",
			[				 rgb(255,255,0),rgb(0,0,255),rgb(0,255,0),rgb(255,0,0) 		   ];
        attribute<uint32>  SymbolColor :=  DialogType = "SymbolColor",
		    [				 rgb(255,255,0),rgb(0,0,255),rgb(0,255,0),rgb(255,0,0) 		   ];
        attribute<float32> SymbolSize  := DialogType = "SymbolSize",  [ 4.0,4.0,4.0,4.0]     ;
        attribute<uint32>  Color :=  DialogType = "BrushColor",
		    [				 rgb(255,255,0),rgb(0,0,255),rgb(0,255,0),rgb(255,0,0) 		   ];
		
		
        container V := for_each_nedv(name, 'value('+string(id(.))+', ..)', void, .);
	}
		
}

	container Units // Definition of value units
	{

//    #include <Classifications.dms> 
 
		unit<float32> nr_inh := baseunit('inhabitants', float32);
		
		unit<float64> m      := baseunit('meter', float64);
		unit<float64> km     := 1000 * m;
		unit<float64> m2     := m * m;

	// no metric
	unit<float64> ratio         := range(1.0 * m2 / m2, 0.0, 1.0)	, cdf = "Classifications/ratio13F/ClassBreaks";
	unit<float64> percent       := 100.0 * ratio;
// , cdf = "Classifications/Percentage13K/ClassBreaks";

		unit<float32> s      := baseunit('second', float32);
		unit<float32> hr     := 3600 * s;

		unit<float32> km_hr  := km / hr;
	}

//    #include<Geography.dms> 
 
	container Geography // Define the extend of the scene and the projection 
	{
		unit<fpoint> rdc_base : format = "EPSG:28992", DialogData = "ngr_layer";               // Rijksdriehoekstelsel, a 2D cartesian coordinate system for the netherlands
		unit<fpoint> rdc_meter      := range(rdc_base, point(0f, 300000f), point(280000f, 625000f)); // Define a 2D range consisting of 2D cartesian coordinates, later used for the "province" domain unit geometry attribute
		unit<fpoint> rdc      := Geography/rdc_meter;

		#include<ngr_layer.dms>                                                                // Tiles for background layer
	}

	container SourceData: Using = "Units"
	{


	container bag_snapshot_result: 
  StorageName     = "%ProjDir%/data/bag_snapshot_20221001/snapshot_20221001.gpkg" // Path to shapefile (2D spatial dataset + N attributes)
, StorageType     = "gdal.vect"
, StorageReadOnly = "True"
, SyncMode        = "allTables"
, DialogData      = "geography/rdc";

    unit<uint32> epdata_c
:  StorageName     = "%ProjDir%/data/v20230101_v2_csv.csv"
,  StorageType     = "gdal.vect"
,  SyncMode        = "allTables"
,  StorageReadOnly = "True" {
    	   attribute<string> ep_pcncmb   := uppercase( Pand_postcode + 
			     Pand_huisnummer + Pand_huisletter +"-" + Pand_huisnummertoevoeging  );
			 attribute<string> ep_klaslet   := substr( Pand_energieklasse,0,1 );
        }

    unit<uint32> epdata_d
:  StorageName     = "%ProjDir%/data/epdata_d.dbf"  
,  SyncMode        = "allTables"
,  StorageReadOnly = "True" {
         attribute<string> Pand_energieklasse  := PAND_ENERG + "";
//		 attribute<string> Pand_gebouwklasse   := PAND_GEBOU ;
//		 attribute<string> Pand_gebruiksoppervlakte_thermische_zone    := PAND_GEBRU ;
        }

	  	  unit<uint32> epdata   :
                    StorageName = "%ProjDir%/data/epdata_f.fss" 
					 ,  SyncMode        = "allTables"
,  StorageReadOnly = "True"       {
         attribute<string> ep_pcncmb;        
		 attribute<string> ep_pcncmbu := uppercase(ep_pcncmb);
		 attribute<string> ep_klaslet   ;
         attribute<string> Pand_energieklasse  ;
		 attribute<string> Pand_gebouwklasse ;
		 attribute<string> Pand_gebruiksoppervlakte_thermische_zone  ;
      } 

    unit<uint32> gemfrompc4c
:  StorageName     = "%ProjDir%/data/gemfrompc4.csv"
,  StorageType     = "gdal.vect"
,  SyncMode        = "allTables"
,  StorageReadOnly = "True" ;

    unit<uint32> gemfrompc4
:  StorageName = "%ProjDir%/data/gemfrompc4f.fss"
,  StorageReadOnly = "True" {

   attribute<string> Postcode4  ;
   attribute<string> Gemeentenaam;

}


    unit<uint32> gemfrompc4d
:  StorageName = "%ProjDir%/data/gemfrompc4d.dbf"
,  StorageReadOnly = "True" ;


//    unit<uint32> gemfrompc4 := gemfrompc4d;

	}


	container ToDbf: Using = "Units"
	{
	     unit<uint32> i_pc4_dbf  := SourceData/gemfrompc4c ,
                    StorageName = "%ProjDir%/data/gemfrompc4d.dbf"        {
         attribute<string> Postcode4  := SourceData/gemfrompc4c/Postcode4;
         attribute<string> Gemeentenaam:= SourceData/gemfrompc4c/Gemeentenaam;
      } 
	  
	  unit<uint32> i_epdat_dbf  := SourceData/epdata_c ,
                    StorageName = "%ProjDir%/data/epdata_d.dbf"        {
         attribute<string> pcncmb  := SourceData/epdata_c/ep_pcncmb;
		 attribute<string> klaslet   := SourceData/epdata_c/ep_klaslet ;
         attribute<string> energiekl   := SourceData/epdata_c/Pand_energieklasse ;
		 attribute<string> gebouwkl   := SourceData/epdata_c/Pand_gebouwklasse ;
		 attribute<string> gebropp   := SourceData/epdata_c/Pand_gebruiksoppervlakte_thermische_zone ;
      } 
	  
	  	  unit<uint32> i_epdat_fss  := SourceData/epdata_c ,
                    StorageName = "%ProjDir%/data/epdata_f.fss"        {
         attribute<string> ep_pcncmb  := SourceData/epdata_c/ep_pcncmb;
		 attribute<string> ep_klaslet  := SourceData/epdata_c/ep_klaslet ;
         attribute<string> Pand_energieklasse  := SourceData/epdata_c/Pand_energieklasse ;
		 attribute<string> Pand_gebouwklasse := SourceData/epdata_c/Pand_gebouwklasse ;
		 attribute<string> Pand_gebruiksoppervlakte_thermische_zone   := SourceData/epdata_c/Pand_gebruiksoppervlakte_thermische_zone ;
      } 
	  
	  unit<uint32> i_gemfrompc4_fss := SourceData/gemfrompc4c
,   StorageName = "%ProjDir%/data/gemfrompc4f.fss"
{

   attribute<string> Postcode4  := SourceData/gemfrompc4c/Postcode4;
   attribute<string> Gemeentenaam:= SourceData/gemfrompc4c/Gemeentenaam;

}
	}
	
	container Results: Using = "Units"
	{

		container koppel1
		{
		    parameter <int32> minopp := Int32( 100.0/2.1 );
		  
		    unit<uint32> selectforlab := subset( 
			    ( SourceData/bag_snapshot_result/vbo/woon == False ) &&   
			    ( SourceData/bag_snapshot_result/vbo/industrie == False ) &&
				( SourceData/bag_snapshot_result/vbo/oppervlakte >=  minopp ) )
                 {
                    attribute<string> nummeraanduiding_id  := SourceData/bag_snapshot_result/vbo/nummeraanduiding_id[Nr_OrgEntity];
                    attribute<Int32> oppervlakte   := SourceData/bag_snapshot_result/vbo/oppervlakte[Nr_OrgEntity];
					attribute<Geography/rdc> geometry   := SourceData/bag_snapshot_result/vbo/geometry[Nr_OrgEntity];
                 }

              
		    unit<uint32> eputil := subset( 
			           ( SourceData/epdata/Pand_gebouwklasse == "U"  ) )
                 {
				    attribute<string> ep_pcncmb   := SourceData/epdata/ep_pcncmbu [Nr_OrgEntity];
                    attribute<string> ep_klaslet  := SourceData/epdata/ep_klaslet [Nr_OrgEntity];
					attribute<string> Pand_gebouwklasse  := SourceData/epdata/Pand_gebouwklasse [Nr_OrgEntity];
					attribute<string> Pand_energieklasse   := SourceData/epdata/Pand_energieklasse  [Nr_OrgEntity];
                    attribute<Float32> oppervlakte   := Float32(SourceData/epdata/Pand_gebruiksoppervlakte_thermische_zone [Nr_OrgEntity]);
                 }
				 
		    attribute<UInt32> adres_idx_vbo (selectforlab ) := rlookup(selectforlab/nummeraanduiding_id,
  			      SourceData/bag_snapshot_result/adres/nummeraanduiding_id );
				  
			attribute<string> adr_pcncmb  (SourceData/bag_snapshot_result/adres) := uppercase( SourceData/bag_snapshot_result/adres/postcode + 
			 String(SourceData/bag_snapshot_result/adres/huisnummer) + SourceData/bag_snapshot_result/adres/Huisletter + "-" + SourceData/bag_snapshot_result/adres/toevoeging) ;
			
		    attribute<UInt32> adres_idx_ep (eputil) :=  rlookup(eputil/ep_pcncmb,  adr_pcncmb );		  
		  
		    unit<uint32> epnoaddr := subset( 
			      IsNull( adres_idx_ep ) &&  
				   ( eputil/ep_pcncmb!= "-" )  &&
                  (  eputil/Pand_gebouwklasse == "U" ) )
				  ,  StorageName = "%ProjDir%/output/epnoaddr.dbf"       
                 {
                    attribute<string> ep_pcncmb_res:= eputil/ep_pcncmb[Nr_OrgEntity];
                    attribute<string> Pand_energieklasse   := eputil/Pand_energieklasse[Nr_OrgEntity];
					attribute<string> ep_pc4  := substr(ep_pcncmb_res,0,4);
			        attribute<string> ep_gemeente := rjoin(ep_pc4,
			              SourceData/gemfrompc4/Postcode4,SourceData/gemfrompc4/Gemeentenaam  );
                 }		 


            // eventueel restgroep matchen zonder toevoeging
			
			// aparte export WEL epo en adres , GEEN VBO record met U
			// let op: dat kunnen ook adresen zijn met kleinere oppervlakten
			// hier indien mogelijk vbo records met U toevoegen

          attribute<UInt32> vbosel_idx_vbo (eputil ) := rlookup( adres_idx_ep , adres_idx_vbo);
		  
		  		    unit<uint32> uitvalvbosel := subset( 
			    ( SourceData/bag_snapshot_result/vbo/woon == False ) 	     )
                 {
                    attribute<string> nummeraanduiding_id  := SourceData/bag_snapshot_result/vbo/nummeraanduiding_id[Nr_OrgEntity];
                    attribute<Int32> oppervlakte   := SourceData/bag_snapshot_result/vbo/oppervlakte[Nr_OrgEntity];
					attribute<bool> industrie  := SourceData/bag_snapshot_result/vbo/industrie[Nr_OrgEntity];
					attribute<Geography/rdc> geometry   := SourceData/bag_snapshot_result/vbo/geometry[Nr_OrgEntity];
                 }
				  attribute<UInt32> adres_idx_uvbo (SourceData/bag_snapshot_result/adres ) := rlookup(
  			      SourceData/bag_snapshot_result/adres/nummeraanduiding_id ,
				  uitvalvbosel/nummeraanduiding_id );
		  
          unit<uint32> epnovbosel := subset( 
			      IsNull( vbosel_idx_vbo) &&  
				   ( eputil/ep_pcncmb!= "-" )  &&
                  (  eputil/Pand_gebouwklasse == "U" ) )
				  ,  StorageName = "%ProjDir%/output/epnoselvbo.dbf"       
                 {
                    attribute<string> ep_pcncmb_res:= eputil/ep_pcncmb[Nr_OrgEntity];
                    attribute<string> Pand_energieklasse   := eputil/Pand_energieklasse[Nr_OrgEntity];
					attribute<float32> ep_opp   := eputil/oppervlakte[Nr_OrgEntity];
					attribute<string> ep_pc4  := substr(ep_pcncmb_res,0,4);
			        attribute<string> ep_gemeente := rjoin(ep_pc4,
			              SourceData/gemfrompc4/Postcode4,SourceData/gemfrompc4/Gemeentenaam  );
				    attribute<UInt32> uvbo_idx := adres_idx_uvbo[adres_idx_ep [Nr_OrgEntity]];
					attribute<int32> vbo_opp   := uitvalvbosel/oppervlakte [uvbo_idx];

					attribute<Geography/rdc> geometry  :=  iif( IsNull(uvbo_idx) || True  ,					     
						  SourceData/bag_snapshot_result/adres/geometry [adres_idx_ep [Nr_OrgEntity]] ,
						  uitvalvbosel/geometry	[uvbo_idx])   ;

					attribute<bool> industrie   := uitvalvbosel/industrie [uvbo_idx];
					attribute<Classifications/UitkomstUitval> uitkomst :=  iif( IsNull(uvbo_idx),
		       const(Classifications/UitkomstUitval/V/geenNietWoon, .), 
			   iif( industrie , const(Classifications/UitkomstUitval/V/Industrie, .),
			      iif( vbo_opp >=  minopp , const(Classifications/UitkomstUitval/V/Uitzoeken, .),
			      const(Classifications/UitkomstUitval/V/Klein, .) ) )) ;
                 }	


            // en nu de echte output
            attribute<UInt32> ep_idx_vbo (selectforlab ) := rlookup(adres_idx_vbo,  adres_idx_ep );
			attribute<string> select_klaslet (selectforlab ) := eputil/ep_klaslet [ep_idx_vbo];
			attribute<string> select_ep_pcncmb (selectforlab ) := adr_pcncmb [adres_idx_vbo];
			attribute<string> select_Straatnaam (selectforlab ) := SourceData/bag_snapshot_result/adres/Straatnaam [adres_idx_vbo];
			attribute<string> select_pc4 (selectforlab ) := substr(select_ep_pcncmb,0,4);
			attribute<string> select_gemeente (selectforlab ) := rjoin(select_pc4,
			    SourceData/gemfrompc4/Postcode4,SourceData/gemfrompc4/Gemeentenaam  );
			
			// code maken dat oude dbf eerst gewist wordt

	  unit<uint32> i_land_dbf  := selectforlab
	       ,    StorageName = "%ProjDir%/output/outp2land.dbf"       
	    {
         attribute<string> pcncmb  :=select_ep_pcncmb;
		 attribute<string> klaslet   := makedefined(select_klaslet," ") ;
         attribute<string> gemeente   := select_gemeente ;
		 attribute<string> straat   := select_Straatnaam ;
		 attribute<float32> ep_opp   := eputil/oppervlakte[ep_idx_vbo] ;
		 attribute<int32> vbo_opp   := selectforlab/oppervlakte ;
// storing geometry does not work		 , DisableStorage ="True" 
		 attribute<Geography/rdc> vbo_geometry   := selectforlab/geometry, DisableStorage ="True"  ;
		 attribute<Geography/rdc> geometry   := SourceData/bag_snapshot_result/adres/geometry[adres_idx_vbo], DisableStorage ="True"  ;
		 attribute<Classifications/Uitkomstcats> uitkomst :=  iif( IsNull(ep_idx_vbo),
		       const(Classifications/Uitkomstcats/V/geen, .), 
			   iif( klaslet <= "C" , const(Classifications/Uitkomstcats/V/OK, .),
			      const(Classifications/Uitkomstcats/V/NOK, .) )) ;
        } 

			unit<uint32> pergemeentecatd := unique(i_land_dbf/gemeente)
// 	               ,    StorageName = "%ProjDir%/output/pergemeented.dbf"  
            {
                  attribute<string>   gemeentenaamd  (pergemeentecatd)  := string( Values);	  
			}
			
			    attribute<uint32>  gem_rel (i_land_dbf) := rlookup(i_land_dbf/gemeente, pergemeentecatd/Values) ;
// functie lijkt niet te werken als verwacht
            
			
	     unit<uint32>  pergemeentecat := pergemeentecatd
	     ,    StorageName = "%ProjDir%/output/pergemeente.dbf"  
          {		 		  
				attribute<int32>   oppervlakte  (pergemeentecatd)  := sum(i_land_dbf/vbo_opp,gem_rel) ;
				attribute<string>    gemeentenaam  (pergemeentecatd)  := first(i_land_dbf/gemeente,gem_rel) ;
				//attribute<uint32>   aantal  (pergemeentecatd)  := count(i_land_dbf/vbo_opp,em_rel) ;
				//attribute<int32>   avg  (pergemeentecatd)  := mean(i_land_dbf/vbo_opp,gem_rel) ;
				unit<uint32> dlopp1 := classifications/Uitkomstcats {
				     attribute<int32>   oppdl (pergemeentecatd)  := sum(
					  iif(i_land_dbf/uitkomst == 1 , i_land_dbf/vbo_opp,Int32(0)),gem_rel) ;
				}
				
                container dlopppct := for_each_nedv(classifications/Uitkomstcats/name,  
				'float32( sum( iif(i_land_dbf/uitkomst == '+string(id(classifications/Uitkomstcats))+' , i_land_dbf/vbo_opp,Int32(0)),gem_rel) ) / float32(oppervlakte) '
				, pergemeentecat , float32);
                attribute<float32>   R_geen  (pergemeentecatd)  :=  dlopppct/geen;
				attribute<float32>   R_NOK  (pergemeentecatd)  :=  dlopppct/NOK;
				attribute<float32>   R_OK  (pergemeentecatd)  :=  dlopppct/OK;     
             // incorrecte naam ?   				
  			     attribute<DPoint> geometry (pergemeentecatd) := add_list(i_land_dbf/geometry,gem_rel) , DisableStorage ="True"  ;
            }


//poging als voor andere opslag
	     unit<uint32>  pergemeentecat2 := pergemeentecat
	     ,    StorageName = "%ProjDir%/output/pergemeente2.dbf"   
			{
				attribute<string>    gemeentenaam  (pergemeentecat)  := ""+ pergemeentecat/ Values;
				attribute<int32>     oppervlakte  (pergemeentecat)  := 0+pergemeentecat/ oppervlakte ;	
                attribute<float32>   R_geen  (pergemeentecat)  := 0.0+pergemeentecat/ dlopppct/geen;
				attribute<float32>   R_NOK  (pergemeentecat)  := 0.0+pergemeentecat/ dlopppct/NOK;
				attribute<float32>   R_OK  (pergemeentecat)  := 0.0+pergemeentecat/ dlopppct/OK;
            }

     }
 


		

		
	}
}